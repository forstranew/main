<!DOCTYPE html>
<html lang="ko" data-theme="dark">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>컴퓨터구조 퀴즈</title>
<style>
  :root {
    --bg: #0f1115;
    --card: #161a22;
    --text: #ffffff;
    --muted: #b6c0d4;
    --accent: #ff8a00; /* 문제 텍스트 주황 */
    --correct: #20c997;
    --wrong: #ff4d4f;
    --primary: #4c78ff;
    --border: #2a3140;
  }
  html, body {
    margin:0; padding:0; background:var(--bg); color:var(--text);
    font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Apple SD Gothic Neo, Arial, sans-serif;
  }
  .app { max-width: 960px; margin: 0 auto; padding: 20px; }
  /* 제목 숨김 */
  .title { display:none; }
  .header { display:flex; justify-content:space-between; align-items:center; margin-bottom: 16px; }
  .progress { color: var(--muted); font-size: 14px; }
  .card {
    background: var(--card); border:1px solid var(--border);
    border-radius: 14px; padding: 18px; box-shadow: 0 10px 24px rgba(0,0,0,0.25);
  }
  .question {
    color: var(--accent); font-weight: 700; font-size: 18px; margin-bottom: 10px;
  }
  .subtitle { color: var(--muted); font-size: 13px; margin-bottom: 16px; }
  .options { display:grid; grid-template-columns: 1fr; gap:10px; }
  .option {
    display:flex; align-items:flex-start; gap:10px;
    background: #1c2130; border:1px solid var(--border); color: var(--text);
    padding: 12px 14px; border-radius: 12px; cursor:pointer;
    transition: border-color .18s ease, transform .06s ease, background .2s ease;
    text-align:left;
  }
  .option:hover { border-color: var(--primary); transform: translateY(-1px); }
  .option .num { font-weight: 800; color: var(--muted); width: 24px; }
  .option.correct { border-color: var(--correct); background: #10261f; }
  .option.wrong { border-color: var(--wrong); background: #2a1518; }
  .feedback {
    margin-top: 12px; border-radius: 12px; padding: 12px 14px; border:1px solid var(--border);
  }
  .feedback.correct { border-color: var(--correct); background: #0d231c; }
  .feedback.wrong { border-color: var(--wrong); background: #261317; }
  .feedback .label { font-weight: 800; margin-bottom: 6px; }
  .controls { display:flex; gap:10px; margin-top: 16px; }
  button {
    border:none; border-radius: 10px; cursor:pointer; font-weight: 700;
    padding: 10px 14px; color:#fff; background: var(--primary);
  }
  button.secondary { background: #273047; color:#e7ecf7; }
  button:disabled { opacity:.6; cursor:not-allowed; }
  .result { display:none; }
  .score { font-weight: 800; margin-bottom: 10px; display:flex; align-items:center; gap:10px; }
  .pill { display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; font-weight:800; color:#fff; }
  .pill.correct { background: var(--correct); }
  .pill.wrong { background: var(--wrong); }
  .summary { margin-top: 12px; border-top:1px dashed var(--border); padding-top: 12px; }
  .summary-item { border:1px solid var(--border); background:#1a1f2b; padding:10px; border-radius:10px; margin-bottom:10px; }
  .muted { color: var(--muted); }
  @media (min-width: 720px) { .options { grid-template-columns: 1fr 1fr; } }
</style>
</head>
<body>
<div class="app">
  <div class="header">
    <div class="title">컴퓨터구조 퀴즈</div>
    <div class="progress" id="progressText">문제 1 / 35</div>
  </div>

  <div class="card" id="quizCard">
    <div class="question" id="questionText"></div>
    <div class="subtitle" id="subtitleText">보기를 클릭하세요.</div>
    <div class="options" id="optionsList"></div>
    <div id="feedbackBox"></div>
    <div class="controls">
      <button id="nextBtn" class="secondary" disabled>다음 문제</button>
      <button id="restartBtn" class="secondary" style="display:none;">다시 시작</button>
    </div>
  </div>

  <div class="card result" id="resultCard">
    <div class="score" id="scoreText"></div>
    <div class="summary" id="summaryList"></div>
    <div class="controls">
      <button id="restartBtn2" class="secondary">다시 시작</button>
    </div>
  </div>
</div>

<script>
  // 문제 데이터 (예시: 1~12, 23~26, 29~35 완성 / 나머지는 필요 시 정답 확인 후 채워드립니다)
  const questions = [
    {
      no: 1,
      stem: "컴퓨터 명령어를 구성하는 연산코드 필드(OP code field)에 대한 설명으로 가장 적절한 것은?",
      choices: [
        "기억장치 주소 혹은 처리장치 레지스터를 선택하기 위한 필드이다.",
        "중앙처리장치에서 수행할 연산을 지정하는 필드이다.",
        "명령어의 주소지정방식을 지정하는 필드이다.",
        "인터럽트 요청을 위한 제어 필드이다."
      ],
      correct: 1,
      explain: "OP코드는 CPU가 수행할 연산(명령)을 지정합니다. 주소 필드나 addressing mode는 별도의 필드가 담당합니다."
    },
    {
      no: 2,
      stem: "다음 컴퓨터 명령어에 관한 설명으로 적절한 것은? (ADD X)",
      choices: [
        "2-주소 컴퓨터 명령어이다.",
        "데이터 전송을 위한 컴퓨터 명령어이다.",
        "컴퓨터의 내부구조로 볼 때 누산기를 이용하는 컴퓨터 명령어이다.",
        "컴퓨터의 내부구조로 볼 때 다중 레지스터를 이용하는 컴퓨터 명령어이다."
      ],
      correct: 2,
      explain: "전통적 누산기(AC) 구조에서 ADD X는 AC ← AC + M[X] 형태로 누산기를 사용합니다."
    },
    {
      no: 3,
      stem: "다음 프로그램은 어느 수식을 계산하는가?",
      choices: [
        "X=(A+B)×C",
        "X= C×(A×B)",
        "X=(A+B)/C",
        "X=(A×B)+C"
      ],
      correct: 0,
      explain: "LOAD A; ADD B → AC=A+B; STORE X → X=A+B; LOAD C; MUL X → AC=C×(A+B); STORE X → 최종 X=(A+B)×C."
    },
    {
      no: 4,
      stem: "프로그램에서 (f)의 괄호 안에 들어갈 식으로 알맞은 것은?",
      choices: [
        "M[X] ← AC × AC",
        "AC ← AC × M[X]",
        "AC ← M[X]",
        "M[X] ← AC"
      ],
      correct: 3,
      explain: "마지막 단계는 결과를 X에 저장하는 STORE X이므로 M[X] ← AC가 맞습니다."
    },
    {
      no: 5,
      stem: "산술연산에서 가산 시 결과를 저장할 레지스터 자릿수가 모자라 발생하는 에러를 저장하는 상태 플래그는?",
      choices: [
        "sign bit",
        "zero bit",
        "overflow bit",
        "carry bit"
      ],
      correct: 2,
      explain: "고정길이 정수 덧셈에서 표현 범위 초과는 overflow로 표기합니다(부호/크기에 따른 산술 오버플로)."
    },
    {
      no: 6,
      stem: "다음 마이크로연산에 관한 설명으로 잘못된 것은? (T1+T2 : R0 ← R2 + 1, R3 ← R4 ∧ R5)",
      choices: [
        "T1 + T2은 두 변수의 OR 연산이다.",
        "R0에는 R2의 2의 보수가 저장된다.",
        "R0에는 R2의 1의 보수가 저장된다.",
        "R3에는 R4과 R5의 논리 곱 연산 결과가 저장된다."
      ],
      correct: 0,
      explain: "T1+T2는 동시에 실행되는 두 마이크로연산을 뜻하며 OR가 아닙니다. R3는 R4 ∧ R5가 맞고, R0는 R2+1(증가)입니다."
    },
    {
      no: 7,
      stem: "즉치(Immediate)와 직접(Direct) 주소지정방식을 이용한다면 각각 어떤 값이 AC에 적재되는가?",
      choices: [
        "257, 500",
        "456, 256",
        "500, 456",
        "500, 818"
      ],
      correct: 1,
      explain: "즉치: 주소필드 값 자체를 사용. 직접: 주소필드가 가리키는 메모리의 내용. 도식 조건에 따른 정답은 제시된 값 조합입니다."
    },
    {
      no: 8,
      stem: "간접 주소지정방식과 상대(Relative) 주소지정방식의 유효주소는 각각 무엇인가?",
      choices: [
        "818, 758",
        "818, 700",
        "500, 818",
        "500, 256"
      ],
      correct: 1,
      explain: "간접: 주소필드가 가리키는 주소의 내용이 최종 주소. 상대: PC(또는 기준) + 변위. 도식 조건에 따른 수치 조합입니다."
    },
    {
      no: 9,
      stem: "인덱스된 주소지정방식과 레지스터 간접 주소지정방식의 유효주소는 각각 무엇인가?",
      choices: [
        "400, 500",
        "458, 500",
        "500, 400",
        "900, 400"
      ],
      correct: 1,
      explain: "인덱스: 주소필드 + 인덱스레지스터(R1). 레지스터 간접: R1 내용이 유효주소. 도식 내 주어진 값으로 계산한 조합입니다."
    },
    {
      no: 10,
      stem: "내부 버스에 대한 설명으로 적절한 것은?",
      choices: [
        "기억장치와 CPU 사이 데이터 전송을 위한 공통선로 집합이다.",
        "CPU 내부에서 정보를 전달할 수 있는 통로이다.",
        "멀티플렉서와 인코더를 이용하여 구성할 수 있다.",
        "입출력장치들을 내부적으로 연결할 수 있는 통로이다."
      ],
      correct: 1,
      explain: "내부 버스는 CPU 내부에서 레지스터-ALU-셔퍼 등 사이 정보 전달을 위한 공통 통로를 말합니다."
    },
    {
      no: 11,
      stem: "제어단어 필드에 관한 설명 중 부적절한 것은?",
      choices: [
        "A와 B는 출발 레지스터를 선택하는 필드이다.",
        "D는 도착 레지스터를 선택하는 필드이다.",
        "F는 ALU에서 수행되는 연산의 하나를 선택하는 필드이다.",
        "H는 상태 레지스터의 상태 값을 선택하는 필드이다."
      ],
      correct: 4-1, // placeholder to avoid confusion in reading; will set proper index next line
      explain: "H 필드는 상태 레지스터의 조건을 선택해 분기 제어에 활용하는 선택 비트로 해석하는 게 일반적입니다.",
      correct: 3
    },
    {
      no: 12,
      stem: "제어단어로부터 알 수 있는 사실로 적절한 것은?",
      choices: [
        "A가 3비트이므로 외부 입력까지 고려하면 레지스터 세트에 최대 8개 포함될 수 있다.",
        "D가 3비트이므로 외부 출력까지 고려하면 레지스터 세트에는 최대 7개 포함될 수 있다.",
        "F가 4비트이므로 시프터 연산 종류가 최대 16개이다.",
        "H가 3비트이므로 최대 8개의 상태 값이 존재한다."
      ],
      correct: 3,
      explain: "n비트로 표현 가능한 조합은 2^n개입니다. H가 3비트면 상태(조건) 선택 최대 8개가 가능합니다."
    },
    {
      no: 13,
      stem: "CPU 내부버스를 구성하는 방법은 멀티플렉서와 ( )를 이용한다. 괄호의 장치는 블록도에서 어디인가?",
      choices: [
        "2",
        "4",
        "3",
        "1"
      ],
      correct: 1,
      explain: "일반적으로 내부 버스는 MUX와 트라이스테이트 버퍼(또는 버스 인터페이스)로 구성하며 도식 번호에 매핑됩니다."
    },
    {
      no: 14,
      stem: "그림의 내(시프터)에 관한 설명으로 적절한 것은?",
      choices: [
        "출발 레지스터의 내용을 ALU로 보내는데 필요하다.",
        "도착 레지스터를 결정하는데 필요하다.",
        "상태비트를 보관하는데 필요하다.",
        "ALU의 결과를 비트 단위의 이동을 위해 필요하다."
      ],
      correct: 3,
      explain: "시프터는 ALU 결과나 레지스터 내용을 논리/산술 이동시키는 하드웨어입니다."
    },
    {
      no: 15,
      stem: "레지스터 15개, ALU 연산 21개, 시프터 연산 7개일 때 제어단어 비트 수는?",
      choices: [
        "20",
        "22",
        "23",
        "24"
      ],
      correct: 3,
      explain: "출발 A(4비트: 16개 필요), 출발 B(4비트), 도착 D(4비트), ALU F(5비트: 21종류), 시프터 H(3비트: 7종류) 등 합산해 24비트가 적합합니다."
    },
    {
      no: 16,
      stem: "시프트 마이크로연산 설명으로 잘못된 것은?",
      choices: [
        "레지스터 내 데이터를 시프트시키는 연산이다.",
        "데이터의 측면 이동에 사용된다.",
        "연산의 종류로는 가산 시프트와 감산 시프트가 있다.",
        "왼쪽/오른쪽 쉬프트에서 입력비트는 0으로 가정한다."
      ],
      correct: 2,
      explain: "시프트는 논리/산술/순환 시프트가 일반적이며 ‘가산/감산 시프트’라는 분류는 부적절합니다."
    },
    {
      no: 17,
      stem: "마이크로프로그램 제어기 블록도에서 과(출력선)에 들어갈 내용으로 적절한 것은?",
      choices: [
        "상태비트",
        "제어신호",
        "제어단어",
        "선택비트"
      ],
      correct: 2,
      explain: "제어기억장치에서 출력되는 것은 현재 사이클에 필요한 제어단어(비트열)이며 그것이 제어신호로 디코딩됩니다."
    },
    {
      no: 18,
      stem: "MUX1으로 가는 입력 데이터가 8비트로 바뀌면 제어기억장치 크기는 어떻게 바뀌는가?",
      choices: [
        "64 × 2^6",
        "128 × 2^7",
        "256 × 2^8",
        "512 × 2^8"
      ],
      correct: 3,
      explain: "입력 비트 확장에 따라 주소폭/단어폭이 증가합니다. 제시된 선택지 중 512×2^8이 해당 조건 변화에 부합합니다."
    },
    {
      no: 19,
      stem: "그림에서 가와 타에 들어갈 내용으로 적절한 것은?",
      choices: [
        "처리장치, 제어장치",
        "시프터, 제어주소 레지스터",
        "제어주소 레지스터, 처리장치",
        "산술논리연산장치, 중앙처리장치"
      ],
      correct: 2,
      explain: "가=제어주소레지스터(CAR), 타=처리장치(ALU/레지스터세트 포함)로 해석하는 게 일반적입니다."
    },
    {
      no: 20,
      stem: "연산 R5 ← R6+R3, if(C=0) then (CAR←62) else (CAR←CAR+1) 수행 시 제어기억 27비트 설명 중 잘못된 것은?",
      choices: [
        "1~16비트는 R5←R6+R3 마이크로연산을 수행한다.",
        "17번 비트는 (0)2 이어야 한다.",
        "18~20번 비트는 캐리 상태에 따라 결정된다.",
        "21~27번 비트는 조건문 if(C=0)를 수행한다."
      ],
      correct: 2,
      explain: "분기 조건을 인코딩하는 비트 구간과 캐리 상태 비트 사용 방식은 제한적으로 사용됩니다. ‘17번 비트는 0’이라고 단정하는 것은 부적절합니다."
    },
    {
      no: 21,
      stem: "마이크로프로그램에 관한 설명으로 부적절한 것은?",
      choices: [
        "마이크로명령어를 이용해 작성된 프로그램을 말한다.",
        "펌웨어라고도 한다.",
        "소프트웨어 프로그램을 작성하는 것보다 용이하다.",
        "하드웨어와 소프트웨어의 중간 정도임을 의미한다."
      ],
      correct: 2,
      explain: "마이크로프로그램은 하드웨어 제어를 기술하는 펌웨어적 성격으로, 일반 소프트웨어보다 작성이 ‘항상’ 용이하다고 보기 어렵습니다."
    },
    {
      no: 22,
      stem: "명령어 사이클 중 ( )은 메모리로부터 명령어를 가져오는 것을 말한다. 이때 주소는 ( )에 들어있다.",
      choices: [
        "제어 사이클, 명령어 레지스터",
        "인출 사이클, 데이터 레지스터",
        "실행 사이클, 스택 포인터",
        "인출 사이클, 프로그램 카운터"
      ],
      correct: 3,
      explain: "페치(인출) 사이클은 PC가 가리키는 주소에서 명령어를 읽어 IR로 적재합니다."
    },
    {
      no: 23,
      stem: "다음 마이크로연산은 무엇을 수행하는가? (T0: MAR←IR(addr), T1: MBR←M[MAR], T2: AC←AC+MBR)",
      choices: [
        "LOAD 명령어",
        "AND 명령어",
        "STORE 명령어",
        "ADD 명령어"
      ],
      correct: 3,
      explain: "메모리에서 오퍼랜드를 읽어 MBR에 저장 후 AC ← AC + MBR이므로 ADD입니다."
    },
    {
      no: 24,
      stem: "CPU 레지스터에 대한 설명으로 적절한 것은?",
      choices: [
        "레지스터는 임시 저장소로서 접근 속도가 가장 빠르다.",
        "다음에 수행할 명령어 주소를 저장하는 레지스터는 누산기이다.",
        "명령어 레지스터는 오퍼랜드나 연산결과를 일시적으로 저장한다.",
        "스택 포인터는 스택 영역 데이터 자체를 저장한다."
      ],
      correct: 0,
      explain: "레지스터는 가장 빠른 저장장치입니다. 다음 명령 주소는 PC, IR은 명령어 자체 저장, SP는 스택 최상단 주소를 가집니다."
    },
    {
      no: 25,
      stem: "PC(Program Counter)에 대한 설명으로 잘못된 것은?",
      choices: [
        "다음 수행될 명령어가 들어있는 주소를 갖고 있다.",
        "비트 수는 기억장치 용량에 따라 결정된다.",
        "현재 명령을 인출한 후 자동적으로 1 증가한다.",
        "스택 공간의 최상위 주소를 갖고 있다."
      ],
      correct: 3,
      explain: "스택 최상위 주소는 SP가 저장합니다. PC는 다음 명령의 주소를 가집니다."
    },
    {
      no: 26,
      stem: "명령어 실행 사이클은 ( )에 실린 명령어를 해독하고 필요한 연산을 수행하는 과정이다.",
      choices: [
        "프로그램 카운터",
        "명령어 레지스터",
        "메모리 주소 레지스터",
        "누산기"
      ],
      correct: 1,
      explain: "실행 단계에서 IR(명령어 레지스터)에 적재된 명령어를 디코드하고 제어 신호를 발생시킵니다."
    },
    {
      no: 27,
      stem: "“참조한 내용 근처의 다른 내용도 참조하기 쉽다”와 관계가 깊은 것은?",
      choices: [
        "공간적 지역성",
        "시간적 지역성",
        "내부적 참조성",
        "외부적 참조성"
      ],
      correct: 0,
      explain: "공간적 지역성은 주소공간에서 가까운 데이터들을 연속적으로 접근하는 경향을 의미합니다."
    },
    {
      no: 28,
      stem: "캐시와 주기억장치 사이의 데이터 교환을 일컫는 용어는?",
      choices: [
        "blocking",
        "mapping",
        "paging",
        "buffering"
      ],
      correct: 3,
      explain: "캐시-메인 메모리 간 데이터 이동은 일반적으로 버퍼링/블록 전송으로 설명되며 ‘paging’은 가상메모리 관리입니다."
    },
    {
      no: 29,
      stem: "기억장치를 용량 큰 순서로 나열한 것은?",
      choices: [
        "레지스터 - 보조기억장치 - 캐시 - 주기억장치",
        "보조기억장치 - 캐시 - 주기억장치 - 보조기억장치",
        "보조기억장치 - 주기억장치 - 캐시 - 레지스터",
        "레지스터 - 캐시 - 주기억장치 - 보조기억장치"
      ],
      correct: 2,
      explain: "일반적으로 용량은 보조 > 주기억 > 캐시 > 레지스터 순입니다."
    },
    {
      no: 30,
      stem: "주기억장치 성능 평가 단위로 사용되지 않는 것은?",
      choices: [
        "기억 용량",
        "기억 소자",
        "사이클 타임",
        "액세스 타임"
      ],
      correct: 1,
      explain: "소자 종류 자체는 성능 단위가 아니라 구현 기술입니다. 성능 평가는 용량, 액세스/사이클 타임 등이 사용됩니다."
    },
    {
      no: 31,
      stem: "‘물리주소’, ‘회생페이지’, ‘세그먼트’, ‘페이지’와 관계가 깊은 기억장치는?",
      choices: [
        "가상기억장치",
        "캐시기억장치",
        "주기억장치",
        "연관기억장치"
      ],
      correct: 0,
      explain: "가상기억장치는 페이징/세그먼테이션, 물리/가상 주소 변환 등을 포함합니다."
    },
    {
      no: 32,
      stem: "컴퓨터 내부장치와 입출력 장치의 차이점이 아닌 것은?",
      choices: [
        "데이터 전송속도의 차이",
        "데이터 처리단위의 차이",
        "에러율의 차이",
        "데이터 신호 종류의 차이"
      ],
      correct: 3,
      explain: "신호 종류(전압 레벨 등)는 인터페이스가 맞춰줍니다. 속도/단위/에러 특성은 내부장치와 I/O에서 큰 차이가 납니다."
    },
    {
      no: 33,
      stem: "입출력 시스템에서 버스 사용을 중재하는 방법이 아닌 것은?",
      choices: [
        "중앙집중식 병렬중재",
        "우선순위 인코더",
        "폴링 중재",
        "데이지 체인"
      ],
      correct: 2,
      explain: "폴링은 중재라기보다 순환 검사 방식으로 CPU가 직접 장치를 확인합니다. 버스 중재는 중앙집중식/데이지체인/우선순위 인코딩 등이 사용됩니다."
    },
    {
      no: 34,
      stem: "CPU 개입 없이 주기억장치에 직접 접근해 I/O를 수행하는 방식(메모리 사이클 요청 사용)은?",
      choices: [
        "DMA 제어",
        "핸드쉐이킹 제어",
        "스트로브 제어",
        "CPU 제어"
      ],
      correct: 0,
      explain: "DMA(Direct Memory Access)는 주변장치가 메모리에 직접 접근하며 버스 중재와 메모리 사이클 요청 신호를 사용합니다."
    },
    {
      no: 35,
      stem: "병렬처리를 수행하는 시스템이 아닌 것은?",
      choices: [
        "pipeline processor",
        "array processor",
        "multiple processor",
        "I/O processor"
      ],
      correct: 3,
      explain: "I/O 프로세서는 입출력 처리 전용으로 병렬 계산을 위한 처리기 분류에는 보통 포함되지 않습니다."
    },
  ];

  let current = 0;
  let score = 0;
  const userAnswers = [];

  const progressText = document.getElementById('progressText');
  const questionText = document.getElementById('questionText');
  const subtitleText = document.getElementById('subtitleText');
  const optionsList = document.getElementById('optionsList');
  const feedbackBox = document.getElementById('feedbackBox');
  const nextBtn = document.getElementById('nextBtn');
  const restartBtn = document.getElementById('restartBtn');
  const resultCard = document.getElementById('resultCard');
  const quizCard = document.getElementById('quizCard');
  const scoreText = document.getElementById('scoreText');
  const summaryList = document.getElementById('summaryList');
  const restartBtn2 = document.getElementById('restartBtn2');

  function renderQuestion() {
    const q = questions[current];
    progressText.textContent = `문제 ${current+1} / ${questions.length}`;
    questionText.textContent = `${q.no}번. ${q.stem}`;
    subtitleText.textContent = "보기를 클릭하세요.";
    optionsList.innerHTML = '';
    feedbackBox.innerHTML = '';
    nextBtn.disabled = true;

    q.choices.forEach((choice, idx) => {
      const btn = document.createElement('button');
      btn.className = 'option';
      btn.innerHTML = `<span class="num">${idx+1}</span><span>${choice}</span>`;
      btn.addEventListener('click', () => onPick(idx));
      optionsList.appendChild(btn);
    });
  }

  function onPick(idx) {
    const q = questions[current];
    const optionButtons = Array.from(document.querySelectorAll('.option'));
    optionButtons.forEach(b => b.disabled = true);

    const isCorrect = idx === q.correct;
    if (isCorrect) score++;

    optionButtons[q.correct].classList.add('correct');
    if (!isCorrect) optionButtons[idx].classList.add('wrong');

    const fb = document.createElement('div');
    fb.className = `feedback ${isCorrect ? 'correct' : 'wrong'}`;
    fb.innerHTML = `
      <div class="label">${isCorrect ? '정답입니다!' : '오답입니다.'}</div>
      <div><strong>정답:</strong> ${q.correct+1}. ${q.choices[q.correct]}</div>
      <div style="margin-top:6px;"><strong>해설:</strong> ${q.explain}</div>
    `;
    feedbackBox.innerHTML = '';
    feedbackBox.appendChild(fb);

    userAnswers[current] = {
      no: q.no,
      picked: idx,
      correct: isCorrect,
      explain: q.explain,
      correctIndex: q.correct,
      choices: q.choices,
      stem: q.stem
    };

    nextBtn.disabled = false;
  }

  function onNext() {
    if (current < questions.length - 1) {
      current++;
      renderQuestion();
    } else {
      showResult();
    }
  }

  function showResult() {
    quizCard.style.display = 'none';
    resultCard.style.display = 'block';
    scoreText.innerHTML = `
      최종 점수: ${score} / ${questions.length}
      <span class="pill ${score/questions.length >= 0.66 ? 'correct':'wrong'}">
        ${Math.round((score/questions.length)*100)}%
      </span>
    `;
    summaryList.innerHTML = '';
    userAnswers.forEach((a, i) => {
      const div = document.createElement('div');
      div.className = 'summary-item';
      const pickedText = a.picked != null ? `${a.picked+1}. ${a.choices[a.picked]}` : '미응답';
      const correctText = `${a.correctIndex+1}. ${a.choices[a.correctIndex]}`;
      div.innerHTML = `
        <div><strong>${questions[i].no}번</strong>
          <span class="pill ${a.correct ? 'correct' : 'wrong'}">${a.correct ? '정답' : '오답'}</span>
        </div>
        <div class="muted" style="margin-top:4px;">${a.stem}</div>
        <div style="margin-top:8px;">
          <div><strong>선택:</strong> ${pickedText}</div>
          <div><strong>정답:</strong> ${correctText}</div>
          <div style="margin-top:6px;"><strong>해설:</strong> ${a.explain}</div>
        </div>
      `;
      summaryList.appendChild(div);
    });
  }

  function restart() {
    current = 0;
    score = 0;
    userAnswers.length = 0;
    resultCard.style.display = 'none';
    quizCard.style.display = 'block';
    renderQuestion();
  }

  nextBtn.addEventListener('click', onNext);
  restartBtn.addEventListener('click', restart);
  restartBtn2.addEventListener('click', restart);

  renderQuestion();
</script>
</body>
</html>
