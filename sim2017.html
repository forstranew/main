<!DOCTYPE html>
<html lang="ko" data-theme="dark">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>시뮬레이션 퀴즈</title>
<style>
  :root {
    --bg: #0f1115;
    --card: #161a22;
    --text: #ffffff;
    --muted: #b6c0d4;
    --accent: #ff8a00; /* 문제 텍스트 주황 */
    --correct: #20c997;
    --wrong: #ff4d4f;
    --primary: #4c78ff;
    --border: #2a3140;
  }
  html, body {
    margin:0; padding:0; background:var(--bg); color:var(--text);
    font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Apple SD Gothic Neo, Arial, sans-serif;
  }
  .app { max-width: 960px; margin: 0 auto; padding: 20px; }
  .title { display:none; } /* 제목 숨김 */
  .header { display:flex; justify-content:space-between; align-items:center; margin-bottom: 16px; }
  .progress { color: var(--muted); font-size: 14px; }
  .card {
    background: var(--card); border:1px solid var(--border);
    border-radius: 14px; padding: 18px; box-shadow: 0 10px 24px rgba(0,0,0,0.25);
  }
  .question { color: var(--accent); font-weight: 700; font-size: 18px; margin-bottom: 10px; }
  .subtitle { color: var(--muted); font-size: 13px; margin-bottom: 16px; }
  .options { display:flex; flex-direction: column; gap:10px; } /* 1열 왼쪽 정렬 */
  .option {
    display:flex; align-items:flex-start; gap:10px;
    background: #1c2130; border:1px solid var(--border); color: var(--text);
    padding: 12px 14px; border-radius: 12px; cursor:pointer;
    transition: border-color .18s ease, transform .06s ease, background .2s ease;
    text-align:left; justify-content:flex-start;
  }
  .option:hover { border-color: var(--primary); transform: translateY(-1px); }
  .option .num { font-weight: 800; color: var(--muted); width: 24px; }
  .option.correct { border-color: var(--correct); background: #10261f; }
  .option.wrong  { border-color: var(--wrong);  background: #2a1518; }
  .feedback { margin-top: 12px; border-radius: 12px; padding: 12px 14px; border:1px solid var(--border); }
  .feedback.correct { border-color: var(--correct); background: #0d231c; }
  .feedback.wrong  { border-color: var(--wrong);  background: #261317; }
  .feedback .label { font-weight: 800; margin-bottom: 6px; }
  .controls { display:flex; gap:10px; margin-top: 16px; }
  button { border:none; border-radius: 10px; cursor:pointer; font-weight: 700; padding: 10px 14px; color:#fff; background: var(--primary); }
  button.secondary { background: #273047; color:#e7ecf7; }
  button:disabled { opacity:.6; cursor:not-allowed; }
  .result { display:none; }
  .score { font-weight: 800; margin-bottom: 10px; display:flex; align-items:center; gap:10px; }
  .pill { display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; font-weight:800; color:#fff; }
  .pill.correct { background: var(--correct); }
  .pill.wrong  { background: var(--wrong); }
  .summary { margin-top: 12px; border-top:1px dashed var(--border); padding-top: 12px; }
  .summary-item { border:1px solid var(--border); background:#1a1f2b; padding:10px; border-radius:10px; margin-bottom:10px; }
  .muted { color: var(--muted); }
</style>
</head>
<body>
<div class="app">
  <div class="header">
    <div class="title">시뮬레이션 퀴즈</div>
    <div class="progress" id="progressText">문제 1 / 35</div>
  </div>

  <div class="card" id="quizCard">
    <div class="question" id="questionText"></div>
    <div class="subtitle" id="subtitleText">보기를 클릭하세요.</div>
    <div class="options" id="optionsList"></div>
    <div id="feedbackBox"></div>
    <div class="controls">
      <button id="nextBtn" class="secondary" disabled>다음 문제</button>
      <button id="restartBtn" class="secondary" style="display:none;">다시 시작</button>
    </div>
  </div>

  <div class="card result" id="resultCard">
    <div class="score" id="scoreText"></div>
    <div class="summary" id="summaryList"></div>
    <div class="controls">
      <button id="restartBtn2" class="secondary">다시 시작</button>
    </div>
  </div>
</div>

<script>
  // 데이터: 36~70 (OCR 반영). 첫 문제부터 choices가 정확히 렌더되도록 점검.
  const questions = [
    {
      no: 36,
      stem: "시뮬레이션 모델 설명과 이름 연결로 바른 것은?\n가. 시스템/문제 정의와 이해 제공 = D 설명적 장치\n나. 한계적 구성요소 결정 = B 분석 도구\n다. 해결방안 종합·평가 = C 설계평가 도구\n라. 미래 개발계획 예측 도움 = A 예측 도구",
      choices: [
        "가-A 나-B 다-C 라-D",
        "가-A 나-C 다-B 라-D",
        "가-D 나-A 다-C 라-B",
        "가-D 나-B 다-C 라-A"
      ],
      correct: 3,
      explain: "가=D, 나=B, 다=C, 라=A의 매칭이므로 4번이 맞습니다."
    },
    {
      no: 37,
      stem: "다음 시뮬레이션 모델에서 확률변수를 사용하지 않는 것은?",
      choices: ["이산형 모델","확률적 모델","결정적 모델","동적 모델"],
      correct: 2,
      explain: "결정적 모델은 난수/확률 변수를 사용하지 않습니다."
    },
    {
      no: 38,
      stem: "천적-먹이 관계 두 종족 상호작용으로 종족수 예측 모델은?",
      choices: ["prey-predator 모델","Vy(t+Δt)=Vy(t)+ay·Δt","저축문제2","몬테칼로 시뮬레이션"],
      correct: 0,
      explain: "포식자-피식자(prey-predator) 모델입니다."
    },
    {
      no: 39,
      stem: "확률적 시뮬레이션에 해당하는 것은?",
      choices: ["저축문제I","대기행렬문제","공의탄성문제","population모델"],
      correct: 1,
      explain: "대기행렬은 확률적 도착/서비스를 다룹니다."
    },
    {
      no: 40,
      stem: "시뮬레이션 특징들 중 잘못된 설명은?",
      choices: [
        "시뮬레이션 모델은 개발 상 많은 비용과 시간을 요한다.",
        "많은 수치 출력은 과잉 신뢰를 줄 수 있다.",
        "확률적 모델은 정확한 값을 요구하는 시스템 최적화에 적합하다.",
        "실시스템 구축 없이도 평가 가능하다."
      ],
      correct: 2,
      explain: "확률적 모델은 단일 ‘정확 값’ 최적화보다 분포/추정용에 적합합니다."
    },
    {
      no: 41,
      stem: "일반적인 시뮬레이션 과정 순서로 올바른 것은?",
      choices: [
        "문제의 정의 → 모델설계 → 자료수집 → 모델변환 → 검증 → 실험",
        "모델설계 → 모델변환 → 문제의 정의 → 자료수집 → 검증 → 실험",
        "자료수집 → 문제의 정의 → 모델설계 → 모델변환 → 검증 → 실험",
        "문제의 정의 → 모델설계 → 모델변환 → 자료수집 → 검증 → 실험"
      ],
      correct: 3,
      explain: "문제 정의 → 설계 → 변환 → 자료수집 → 검증 → 실험의 흐름."
    },
    {
      no: 42, stem: "난수의 초기값(시드) 변수는?", choices: ["tstep","prarr","seed","mean"], correct: 2, explain: "seed가 시드입니다." },
    {
      no: 43, stem: "고객 도착 비율 변수는?", choices: ["tstep","prarr","seed","mean"], correct: 1, explain: "prarr는 단위시간 도착 확률." },
    {
      no: 44, stem: "누적 도착 고객 수 변수는?", choices: ["queue","totque","totarr","tpump"], correct: 2, explain: "totarr는 누적 도착 수." },
    {
      no: 45, stem: "고객 봉사(서비스) 시간 변수는?", choices: ["queue","totque","totarr","tpump"], correct: 3, explain: "tpump가 남은 서비스 시간."
    },
    {
      no: 46,
      stem: "평균 대기행렬 길이 공식 '가'에 적당한 것은?",
      choices: [
        "totque / totarr",
        "totque / arrive",
        "totque / queue",
        "totque / (tlimit / tstep)"
      ],
      correct: 3,
      explain: "시간 평균 큐 길이 = totque / (총 시간 스텝 수)."
    },
    {
      no: 47,
      stem: "평균 대기시간 공식 '나'에 적당한 것은?",
      choices: [
        "totque / totarr",
        "totque / arrive",
        "totque / queue",
        "totque / (tlimit/tstep)"
      ],
      correct: 0,
      explain: "고객 1명당 평균 대기시간 ≈ totque / totarr."
    },
    {
      no: 48,
      stem: "봉사창구를 2개로 늘릴 때 직접 수정되는 변수는?",
      choices: ["queue","totque","tpump","totarr"],
      correct: 2,
      explain: "서비스 처리 로직(tpump)을 다중 채널로 수정."
    },
    {
      no: 49,
      stem: "알고리즘 빈칸 '가'에 알맞은 것은?",
      choices: [
        "call random(nseed,nmean,U)",
        "call random(nseed,nmean,stdev,liters)",
        "call normal(nseed,nmean,stdev,liters)",
        "call normal(nseed,prarr,stdev,liters)"
      ],
      correct: 2,
      explain: "연료 탱크는 정규분포 → normal 호출."
    },
    {
      no: 50,
      stem: "봉사시간을 나타내는 것은?",
      choices: ["liters","queue","tpump","aveque"],
      correct: 2,
      explain: "tpump가 남은 봉사시간."
    },
    {
      no: 51,
      stem: "빈칸 도착간격은?",
      choices: ["1, 2, 2","2, 3, 2","3, 3, 3","9, 11, 15"],
      correct: 1,
      explain: "도착시간 1→3(+2), 3→6(+3), 6→8(+2)."
    },
    {
      no: 52,
      stem: "빈칸 출발시간은?",
      choices: ["1, 2, 2","2, 3, 2","3, 3, 3","9, 11, 15"],
      correct: 3,
      explain: "서비스 직렬 누적으로 제시 답 9,11,15."
    },
    {
      no: 53,
      stem: "빈칸 대기시간은?",
      choices: ["1, 2, 2","2, 3, 2","3, 3, 3","8, 10, 14"],
      correct: 3,
      explain: "표 의도에 따라 누적 대기시간 8,10,14."
    },
    { no: 54, stem: "도착과 출발이 동시에 일어나는 시간은?", choices: ["1","3","6","8"], correct: 2, explain: "6 시점 동시." },
    {
      no: 55,
      stem: "이산형 시뮬레이션 설명 중 틀린 것은?",
      choices: [
        "아무 때나 이산 변화면 이산형, 명시된 순간만이면 연속형.",
        "사건발생 시간에 종속변수가 이산적으로 변한다.",
        "대기행렬은 이산형 시뮬레이션 예다.",
        "사건발생시간 사이에는 종속변수가 변하지 않는다."
      ],
      correct: 0,
      explain: "연속형은 시간에 따라 연속변화, 이산형은 사건 시점에만 변화."
    },
    {
      no: 56,
      stem: "연속형 시뮬레이션 모델링인 경우는?",
      choices: ["대기행렬 시스템","미분방정식처럼 도함수로 표시","특정 종 수 순간 감소","결합 후 방정식 변경"],
      correct: 1,
      explain: "연속형은 ODE 기반처럼 상태가 연속적으로 변화."
    },
    {
      no: 57,
      stem: "가변시간 진행법과 관계없는 것은?",
      choices: ["사건 발생 시 시간 진행","증가시간 일정하지 않음","고정시간 진행법과 반대","최종 시뮬레이션 시간 고정"],
      correct: 3,
      explain: "가변시간은 종료시간도 유동적일 수 있음."
    },
    { no: 58, stem: "종료조건으로 처리해야 할 총 고객수는?", choices: ["totarr","timing","next","nseed"], correct: 0, explain: "totarr 기준." },
    {
      no: 59,
      stem: "빈칸 '가'에 알맞은 것은?",
      choices: [
        "call expon(seed, marrvt, e_arr)",
        "call expon(seed, mservt, e_arr)",
        "call expon(seed, marrvt, tne[1])",
        "call expon(seed, mservt, tne[1])"
      ],
      correct: 0,
      explain: "도착 간격 e_arr는 평균 도착 marrvt 기반 지수분포."
    },
    {
      no: 60,
      stem: "빈칸 '나'에 알맞은 것은?",
      choices: [
        "call expon(nseed, marrvt, tne[2])",
        "call expon(nseed, mservt, tne[2])",
        "call expon(nseed, marrvt, e_dep)",
        "call expon(nseed, mservt, e_dep)"
      ],
      correct: 1,
      explain: "출발(서비스) 시간은 mservt 기반 지수분포로 tne[2] 설정."
    },
    { no: 61, stem: "시뮬레이션 전용언어가 아닌 것은?", choices: ["AweSim","ProModel","AutoMod","Visual C++"], correct: 3, explain: "Visual C++는 범용 언어." },
    {
      no: 62,
      stem: "시뮬레이션 언어 설명 중 틀린 것은?",
      choices: [
        "모델 설계 구조 제시",
        "모델을 프로그램으로 신속 변환",
        "모델 변경 즉시 적용",
        "출력 보고서 형태를 자유롭게 작성"
      ],
      correct: 3,
      explain: "보고서 커스터마이징은 제한적일 수 있어 ‘자유롭게’는 과장."
    },
    {
      no: 63,
      stem: "컴퓨터 난수 발생에서 갖추어야 할 점이 아닌 것은?",
      choices: ["반복발생 불가능","상관관계 없어야 함","발생속도 빨라야 함","[0,1) 일양분포 만족"],
      correct: 0,
      explain: "의사난수는 재현 가능해야 검증이 용이."
    },
    { no: 64, stem: "Xi = 2Xi-1 + 3 (mod 10), X0=5일 때 X1은?", choices: ["3","5","6","9"], correct: 1-1, explain: "X1=(2*5+3)%10=13%10=3.", correct: 0 },
    { no: 65, stem: "같은 식에서 X2는?", choices: ["3","5","6","9"], correct: 3, explain: "X2=(2*3+3)%10=9." },
    { no: 66, stem: "위 발생식의 주기는?", choices: ["3","4","5","6"], correct: 1, explain: "선택지 기준 4." },
    { no: 67, stem: "χ² 검정 자유도? (6000개 난수, 100구간)", choices: ["99","100","101","102"], correct: 0, explain: "k-1=99." },
    { no: 68, stem: "구간별 기대값 n/k는?", choices: ["30","40","50","60"], correct: 3, explain: "6000/100=60." },
    { no: 69, stem: "지수 확률변수 역함수 방법 이름은?", choices: ["역변환법","합성법","결합법","채택기각법"], correct: 0, explain: "Inverse Transform." },
    { no: 70, stem: "목적이 나머지와 가장 다른 응용사례는?", choices: ["일기예보","자동차 드라이빙 시뮬레이터","원자력 발전소 시뮬레이터","파일럿 시뮬레이션"], correct: 0, explain: "일기예보는 예측, 나머지는 훈련/안전." }
  ];

  let current = 0;
  let score = 0;
  const userAnswers = [];

  const progressText = document.getElementById('progressText');
  const questionText = document.getElementById('questionText');
  const subtitleText = document.getElementById('subtitleText');
  const optionsList = document.getElementById('optionsList');
  const feedbackBox = document.getElementById('feedbackBox');
  const nextBtn = document.getElementById('nextBtn');
  const restartBtn = document.getElementById('restartBtn');
  const resultCard = document.getElementById('resultCard');
  const quizCard = document.getElementById('quizCard');
  const scoreText = document.getElementById('scoreText');
  const summaryList = document.getElementById('summaryList');
  const restartBtn2 = document.getElementById('restartBtn2');

  function safeText(el, txt) { el.textContent = txt ?? ""; }

  function renderQuestion() {
    const q = questions[current];
    progressText.textContent = `문제 ${current+1} / ${questions.length}`;
    safeText(questionText, `${q.no}번. ${q.stem}`);
    subtitleText.textContent = "보기를 클릭하세요.";
    optionsList.innerHTML = '';
    feedbackBox.innerHTML = '';
    nextBtn.disabled = true;

    if (!q || !Array.isArray(q.choices) || q.choices.length === 0) {
      const warn = document.createElement('div');
      warn.className = 'feedback wrong';
      warn.innerHTML = '<div class="label">오류</div><div>이 문항의 보기 데이터가 비어있습니다.</div>';
      feedbackBox.appendChild(warn);
      return;
    }

    q.choices.forEach((choice, idx) => {
      const btn = document.createElement('button');
      btn.className = 'option';
      const num = document.createElement('span');
      num.className = 'num';
      safeText(num, String(idx+1));
      const text = document.createElement('span');
      safeText(text, choice);
      btn.appendChild(num);
      btn.appendChild(text);
      btn.addEventListener('click', () => onPick(idx));
      optionsList.appendChild(btn);
    });
  }

  function onPick(idx) {
    const q = questions[current];
    const optionButtons = Array.from(document.querySelectorAll('.option'));
    optionButtons.forEach(b => b.disabled = true);

    const isCorrect = idx === q.correct;
    if (isCorrect) score++;

    optionButtons[q.correct]?.classList.add('correct');
    if (!isCorrect) optionButtons[idx]?.classList.add('wrong');

    const fb = document.createElement('div');
    fb.className = `feedback ${isCorrect ? 'correct' : 'wrong'}`;
    const label = document.createElement('div');
    label.className = 'label';
    safeText(label, isCorrect ? '정답입니다!' : '오답입니다.');
    const ans = document.createElement('div');
    ans.innerHTML = `<strong>정답:</strong> ${q.correct+1}. ${q.choices[q.correct]}`;
    const exp = document.createElement('div');
    exp.style.marginTop = '6px';
    exp.innerHTML = `<strong>해설:</strong> ${q.explain}`;
    fb.appendChild(label);
    fb.appendChild(ans);
    fb.appendChild(exp);

    feedbackBox.innerHTML = '';
    feedbackBox.appendChild(fb);

    userAnswers[current] = {
      no: q.no, picked: idx, correct: isCorrect, explain: q.explain,
      correctIndex: q.correct, choices: q.choices, stem: q.stem
    };

    nextBtn.disabled = false;
  }

  function onNext() {
    if (current < questions.length - 1) {
      current++;
      renderQuestion();
    } else {
      showResult();
    }
  }

  function showResult() {
    quizCard.style.display = 'none';
    resultCard.style.display = 'block';
    const pct = Math.round((score/questions.length)*100);
    scoreText.innerHTML = `
      최종 점수: ${score} / ${questions.length}
      <span class="pill ${score/questions.length >= 0.66 ? 'correct':'wrong'}">${pct}%</span>
    `;
    summaryList.innerHTML = '';
    userAnswers.forEach((a, i) => {
      const div = document.createElement('div');
      div.className = 'summary-item';
      const pickedText = a.picked != null ? `${a.picked+1}. ${a.choices[a.picked]}` : '미응답';
      const correctText = `${a.correctIndex+1}. ${a.choices[a.correctIndex]}`;
      div.innerHTML = `
        <div><strong>${questions[i].no}번</strong>
          <span class="pill ${a.correct ? 'correct' : 'wrong'}">${a.correct ? '정답' : '오답'}</span>
        </div>
        <div class="muted" style="margin-top:4px;">${a.stem}</div>
        <div style="margin-top:8px;">
          <div><strong>선택:</strong> ${pickedText}</div>
          <div><strong>정답:</strong> ${correctText}</div>
          <div style="margin-top:6px;"><strong>해설:</strong> ${a.explain}</div>
        </div>
      `;
      summaryList.appendChild(div);
    });
  }

  function restart() {
    current = 0; score = 0; userAnswers.length = 0;
    resultCard.style.display = 'none';
    quizCard.style.display = 'block';
    renderQuestion();
  }

  nextBtn.addEventListener('click', onNext);
  restartBtn.addEventListener('click', restart);
  restartBtn2.addEventListener('click', restart);

  // 초기 렌더
  renderQuestion();
</script>
</body>
</html>
