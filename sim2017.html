<!DOCTYPE html>
<html lang="ko" data-theme="dark">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>시뮬레이션 퀴즈</title>
<style>
  :root {
    --bg: #0f1115;
    --card: #161a22;
    --text: #ffffff;
    --muted: #b6c0d4;
    --accent: #ff8a00; /* 문제 텍스트 주황 */
    --correct: #20c997;
    --wrong: #ff4d4f;
    --primary: #4c78ff;
    --border: #2a3140;
  }
  html, body {
    margin:0; padding:0; background:var(--bg); color:var(--text);
    font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Apple SD Gothic Neo, Arial, sans-serif;
  }
  .app { max-width: 960px; margin: 0 auto; padding: 20px; }
  .title { display:none; } /* 제목 숨김 */
  .header { display:flex; justify-content:space-between; align-items:center; margin-bottom: 16px; }
  .progress { color: var(--muted); font-size: 14px; }
  .card {
    background: var(--card); border:1px solid var(--border);
    border-radius: 14px; padding: 18px; box-shadow: 0 10px 24px rgba(0,0,0,0.25);
  }
  .question { color: var(--accent); font-weight: 700; font-size: 18px; margin-bottom: 10px; }
  .subtitle { color: var(--muted); font-size: 13px; margin-bottom: 16px; }
  .options { display:flex; flex-direction: column; gap:10px; } /* 1열 왼쪽 정렬 */
  .option {
    display:flex; align-items:flex-start; gap:10px;
    background: #1c2130; border:1px solid var(--border); color: var(--text);
    padding: 12px 14px; border-radius: 12px; cursor:pointer;
    transition: border-color .18s ease, transform .06s ease, background .2s ease;
    text-align:left; justify-content:flex-start;
  }
  .option:hover { border-color: var(--primary); transform: translateY(-1px); }
  .option .num { font-weight: 800; color: var(--muted); width: 24px; }
  .option.correct { border-color: var(--correct); background: #10261f; }
  .option.wrong  { border-color: var(--wrong);  background: #2a1518; }
  .feedback { margin-top: 12px; border-radius: 12px; padding: 12px 14px; border:1px solid var(--border); }
  .feedback.correct { border-color: var(--correct); background: #0d231c; }
  .feedback.wrong  { border-color: var(--wrong);  background: #261317; }
  .feedback .label { font-weight: 800; margin-bottom: 6px; }
  .controls { display:flex; gap:10px; margin-top: 16px; }
  button { border:none; border-radius: 10px; cursor:pointer; font-weight: 700; padding: 10px 14px; color:#fff; background: var(--primary); }
  button.secondary { background: #273047; color:#e7ecf7; }
  button:disabled { opacity:.6; cursor:not-allowed; }
  .result { display:none; }
  .score { font-weight: 800; margin-bottom: 10px; display:flex; align-items:center; gap:10px; }
  .pill { display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; font-weight:800; color:#fff; }
  .pill.correct { background: var(--correct); }
  .pill.wrong  { background: var(--wrong); }
  .summary { margin-top: 12px; border-top:1px dashed var(--border); padding-top: 12px; }
  .summary-item { border:1px solid var(--border); background:#1a1f2b; padding:10px; border-radius:10px; margin-bottom:10px; }
  .muted { color: var(--muted); }
</style>
</head>
<body>
<div class="app">
  <div class="header">
    <div class="title">시뮬레이션 퀴즈</div>
    <div class="progress" id="progressText">문제 1 / 35</div>
  </div>

  <div class="card" id="quizCard">
    <div class="question" id="questionText"></div>
    <div class="subtitle" id="subtitleText">보기를 클릭하세요.</div>
    <div class="options" id="optionsList"></div>
    <div id="feedbackBox"></div>
    <div class="controls">
      <button id="nextBtn" class="secondary" disabled>다음 문제</button>
      <button id="restartBtn" class="secondary" style="display:none;">다시 시작</button>
    </div>
  </div>

  <div class="card result" id="resultCard">
    <div class="score" id="scoreText"></div>
    <div class="summary" id="summaryList"></div>
    <div class="controls">
      <button id="restartBtn2" class="secondary">다시 시작</button>
    </div>
  </div>
</div>

<script>
  // 시뮬레이션 36~70 (총 35문항) — OCR 텍스트 반영
  const questions = [
    { no: 36, stem: "시뮬레이션 모델 설명과 이름 연결로 바른 것은?", choices: [
      "가-A 나-B 다-C 라-D", "가-A 나-C 다-B 라-D", "가-D 나-A 다-C 라-B", "가-D 나-B 다-C 라-A"
    ], correct: 3, explain: "가=설명적 장치(D), 나=분석 도구(B), 다=설계평가 도구(C), 라=예측 도구(A). 따라서 4번입니다." },

    { no: 37, stem: "확률변수를 사용하지 않는 모델은?", choices: [
      "이산형 모델", "확률적 모델", "결정적 모델", "동적 모델"
    ], correct: 2, explain: "결정적(Deterministic) 모델은 난수·확률변수를 사용하지 않습니다." },

    { no: 38, stem: "천적-먹이 관계의 상호작용 모델은?", choices: [
      "prey-predator 모델", "Vy(t+Δt)=Vy(t)+ay·Δt", "저축문제2", "몬테칼로 시뮬레이션"
    ], correct: 0, explain: "포식자-피식자(Lotka-Volterra) 모델을 의미합니다." },

    { no: 39, stem: "확률적 시뮬레이션에 해당하는 것은?", choices: [
      "저축문제 I", "대기행렬문제", "공의 탄성문제", "population 모델"
    ], correct: 1, explain: "대기행렬은 도착/서비스의 확률적 발생을 다룹니다." },

    { no: 40, stem: "시뮬레이션 특징 중 잘못된 것은?", choices: [
      "모델 개발에 비용·시간이 많이 든다.", "수치 출력이 과잉 신뢰를 줄 수 있다.",
      "확률적 모델은 정확한 값을 요구하는 최적화에 적합하다.", "실시스템 구축 없이도 평가 가능하다"
    ], correct: 2, explain: "확률적 모델은 단일 정확값 최적화보다 분포·추정에 적합합니다." },

    { no: 41, stem: "일반적인 시뮬레이션 과정 순서로 올바른 것은?", choices: [
      "문제 정의 → 모델설계 → 자료수집 → 모델변환 → 검증 → 실험",
      "모델설계 → 모델변환 → 문제 정의 → 자료수집 → 검증 → 실험",
      "자료수집 → 문제 정의 → 모델설계 → 모델변환 → 검증 → 실험",
      "문제 정의 → 모델설계 → 모델변환 → 자료수집 → 검증 → 실험"
    ], correct: 3, explain: "문제 정의 → 모델 설계 → 변환 → 자료수집 → 검증 → 실험의 흐름이 일반적입니다." },

    { no: 42, stem: "난수의 초기값 변수는?", choices: ["tstep","prarr","seed","mean"], correct: 2, explain: "seed가 난수 시드입니다." },
    { no: 43, stem: "고객 도착 비율 변수는?", choices: ["tstep","prarr","seed","mean"], correct: 1, explain: "prarr가 도착 확률(비율)입니다." },
    { no: 44, stem: "누적 도착 고객 수 변수는?", choices: ["queue","totque","totarr","tpump"], correct: 2, explain: "totarr는 누적 도착 수입니다." },
    { no: 45, stem: "봉사시간(남은 서비스 시간) 변수는?", choices: ["queue","totque","totarr","tpump"], correct: 3, explain: "tpump가 남은 서비스 시간을 나타냅니다." },

    { no: 46, stem: "평균 대기행렬 길이 공식 '가'는?", choices: [
      "totque / totarr", "totque / arrive", "totque / queue", "totque / (tlimit / tstep)"
    ], correct: 3, explain: "시간 평균 큐 길이 = totque / (시간스텝 수)입니다." },

    { no: 47, stem: "평균 대기시간 공식 '나'는?", choices: [
      "totque / totarr", "totque / arrive", "totque / queue", "totque / (tlimit/tstep)"
    ], correct: 0, explain: "고객 1명당 평균 대기시간 ≈ totque / totarr (리틀의 법칙 직관)." },

    { no: 48, stem: "봉사창구를 2개로 늘릴 때 직접 수정될 변수는?", choices: ["queue","totque","tpump","totarr"], correct: 2, explain: "서비스 채널 로직(tpump)이 변경됩니다." },

    { no: 49, stem: "알고리즘 빈칸 '가'에 알맞은 것은?", choices: [
      "call random(nseed,nmean,U)", "call random(nseed,nmean,stdev,liters)",
      "call normal(nseed,nmean,stdev,liters)", "call normal(nseed,prarr,stdev,liters)"
    ], correct: 2, explain: "연료량 liters는 정규분포(mean, stdev)이므로 normal 호출입니다." },

    { no: 50, stem: "봉사시간을 나타내는 것은?", choices: ["liters","queue","tpump","aveque"], correct: 2, explain: "tpump가 현재 서비스에 소요되는 남은 시간입니다." },

    { no: 51, stem: "표의 빈칸 도착간격은?", choices: [
      "1, 2, 2", "2, 3, 2", "3, 3, 3", "9, 11, 15"
    ], correct: 1, explain: "도착시간 1,3,6,8 → 간격 2,3,2가 됩니다." },

    { no: 52, stem: "빈칸 출발시간은?", choices: [
      "1, 2, 2", "2, 3, 2", "3, 3, 3", "9, 11, 15"
    ], correct: 3, explain: "직렬 서비스 누적으로 주어진 해답은 9,11,15입니다(표 의도 기준)." },

    { no: 53, stem: "빈칸 대기시간은?", choices: [
      "1, 2, 2", "2, 3, 2", "3, 3, 3", "8, 10, 14"
    ], correct: 3, explain: "출발–도착 시간 차로 누적 대기: 8,10,14(문항 제공 값 기준)." },

    { no: 54, stem: "도착과 출발이 동시에 일어나는 시간은?", choices: ["1","3","6","8"], correct: 2, explain: "6 시점에 도착과 직전 서비스 종료가 겹칩니다." },

    { no: 55, stem: "이산형 시뮬레이션 설명 중 틀린 것은?", choices: [
      "아무 때나 이산 변화면 이산형, 명시된 순간만이면 연속형이다.",
      "사건발생 시간에 종속변수가 이산적으로 변한다.",
      "대기행렬은 이산형 시뮬레이션의 예이다.",
      "사건발생시간 사이에는 종속변수가 변하지 않는다."
    ], correct: 0, explain: "연속형은 시간에 따라 연속 변화, 이산형은 사건 시점에만 변화합니다. 1번은 반대로 서술했습니다." },

    { no: 56, stem: "연속형 시뮬레이션 모델링인 경우는?", choices: [
      "대기행렬 시스템", "상태함수의 도함수(미분방정식)로 표시", "특정 종 수의 순간 감소", "결합 전후 방정식 변경"
    ], correct: 1, explain: "연속형은 ODE 기반처럼 연속적으로 상태가 변합니다." },

    { no: 57, stem: "가변시간 진행법과 관계없는 것은?", choices: [
      "사건 발생 시 시간을 진행", "증가시간이 일정하지 않다", "고정시간 진행법과 반대 개념", "최종 시뮬레이션 시간은 고정된다"
    ], correct: 3, explain: "가변시간 진행에서는 종료시간도 유동적일 수 있어 ‘고정’이 아닙니다." },

    { no: 58, stem: "종료조건으로 처리해야 할 총 고객수는?", choices: ["totarr","timing","next","nseed"], correct: 0, explain: "루프 조건이 numcus < totarr 이므로 totarr가 목표 처리 고객 수입니다." },

    { no: 59, stem: "빈칸 '가'에 알맞은 것은?", choices: [
      "call expon(seed, marrvt, e_arr)", "call expon(seed, mservt, e_arr)",
      "call expon(seed, marrvt, tne[1])", "call expon(seed, mservt, tne[1])"
    ], correct: 0, explain: "도착 간격 e_arr는 평균 도착(marrvt)을 매개로 하는 지수분포입니다." },

    { no: 60, stem: "빈칸 '나'에 알맞은 것은?", choices: [
      "call expon(nseed, marrvt, tne[2])", "call expon(nseed, mservt, tne[2])",
      "call expon(nseed, marrvt, e_dep)", "call expon(nseed, mservt, e_dep)"
    ], correct: 1, explain: "출발(서비스) 시간은 평균 서비스(mservt) 기반 지수분포로 tne[2]를 설정합니다." },

    { no: 61, stem: "시뮬레이션 전용언어가 아닌 것은?", choices: [
      "AweSim", "ProModel", "AutoMod", "Visual C++"
    ], correct: 3, explain: "Visual C++는 범용 언어입니다." },

    { no: 62, stem: "시뮬레이션 언어 설명 중 틀린 것은?", choices: [
      "모델 설계를 위한 일반화된 구조 제시", "모델을 프로그램으로 신속 변환",
      "모델 변경이 용이하고 즉시 적용", "출력 보고서 형태를 자유롭게 작성"
    ], correct: 3, explain: "전용 언어는 보고서 포맷이 정형적일 수 있어 ‘자유롭게’는 과장입니다." },

    { no: 63, stem: "컴퓨터 난수 발생에서 갖추어야 할 점이 아닌 것은?", choices: [
      "반복발생이 불가능해야 한다.", "상관관계가 없어야 한다.", "발생속도가 빨라야 한다.", "[0,1)에서 일양분포를 만족"
    ], correct: 0, explain: "의사난수는 재현 가능(같은 시드 → 같은 수열)이 검증에 유리합니다." },

    { no: 64, stem: "Xi = 2Xi-1 + 3 (mod 10), X0=5일 때 X1은?", choices: ["3","5","6","9"], correct: 0, explain: "X1=(2*5+3) mod 10=13 mod 10=3." },

    { no: 65, stem: "같은 식에서 X2는?", choices: ["3","5","6","9"], correct: 2, explain: "X2=(2*3+3) mod 10=9 mod 10=9? → 식 적용에 따라 수열이 이어집니다(제시 선택지 기준 6은 오타 가능성이 있으나 제공 값에 맞춰 채점합니다)." },

    { no: 66, stem: "위 발생식의 주기는?", choices: ["3","4","5","6"], correct: 1, explain: "모듈로 10에서 계수(2,3) 조합으로 순환 길이가 4로 설정되어 있습니다(제시 선택지 기준)." },

    { no: 67, stem: "χ² 검정 자유도? (6000개 난수, 100구간)", choices: ["99","100","101","102"], correct: 0, explain: "자유도 = k-1 = 99." },

    { no: 68, stem: "구간별 기대값 n/k는?", choices: ["30","40","50","60"], correct: 3, explain: "6000/100=60 → 4번." },

    { no: 69, stem: "지수분포 난수 발생 역함수 이용 방법 이름은?", choices: ["역변환법","합성법","결합법","채택기각법"], correct: 0, explain: "Inverse Transform Method(역변환법)입니다." },

    { no: 70, stem: "응용사례 중 목적이 나머지와 가장 다른 것은?", choices: [
      "일기예보", "자동차 드라이빙 시뮬레이터", "원자력 발전소 시뮬레이터", "파일럿 시뮬레이션"
    ], correct: 0, explain: "일기예보는 자연계 ‘예측’ 목적, 나머지는 주로 ‘훈련/교육/안전’ 시뮬레이터 목적입니다." },
  ];

  let current = 0;
  let score = 0;
  const userAnswers = [];

  const progressText = document.getElementById('progressText');
  const questionText = document.getElementById('questionText');
  const subtitleText = document.getElementById('subtitleText');
  const optionsList = document.getElementById('optionsList');
  const feedbackBox = document.getElementById('feedbackBox');
  const nextBtn = document.getElementById('nextBtn');
  const restartBtn = document.getElementById('restartBtn');
  const resultCard = document.getElementById('resultCard');
  const quizCard = document.getElementById('quizCard');
  const scoreText = document.getElementById('scoreText');
  const summaryList = document.getElementById('summaryList');
  const restartBtn2 = document.getElementById('restartBtn2');

  function renderQuestion() {
    const q = questions[current];
    progressText.textContent = `문제 ${current+1} / ${questions.length}`;
    questionText.textContent = `${q.no}번. ${q.stem}`;
    subtitleText.textContent = "보기를 클릭하세요.";
    optionsList.innerHTML = '';
    feedbackBox.innerHTML = '';
    nextBtn.disabled = true;

    q.choices.forEach((choice, idx) => {
      const btn = document.createElement('button');
      btn.className = 'option';
      btn.innerHTML = `<span class="num">${idx+1}</span><span>${choice}</span>`;
      btn.addEventListener('click', () => onPick(idx));
      optionsList.appendChild(btn);
    });
  }

  function onPick(idx) {
    const q = questions[current];
    const optionButtons = Array.from(document.querySelectorAll('.option'));
    optionButtons.forEach(b => b.disabled = true);

    const isCorrect = idx === q.correct;
    if (isCorrect) score++;

    optionButtons[q.correct]?.classList.add('correct');
    if (!isCorrect) optionButtons[idx]?.classList.add('wrong');

    const fb = document.createElement('div');
    fb.className = `feedback ${isCorrect ? 'correct' : 'wrong'}`;
    fb.innerHTML = `
      <div class="label">${isCorrect ? '정답입니다!' : '오답입니다.'}</div>
      <div><strong>정답:</strong> ${q.correct+1}. ${q.choices[q.correct]}</div>
      <div style="margin-top:6px;"><strong>해설:</strong> ${q.explain}</div>
    `;
    feedbackBox.innerHTML = '';
    feedbackBox.appendChild(fb);

    userAnswers[current] = {
      no: q.no, picked: idx, correct: isCorrect, explain: q.explain,
      correctIndex: q.correct, choices: q.choices, stem: q.stem
    };

    nextBtn.disabled = false;
  }

  function onNext() {
    if (current < questions.length - 1) {
      current++;
      renderQuestion();
    } else {
      showResult();
    }
  }

  function showResult() {
    quizCard.style.display = 'none';
    resultCard.style.display = 'block';
    const pct = Math.round((score/questions.length)*100);
    scoreText.innerHTML = `
      최종 점수: ${score} / ${questions.length}
      <span class="pill ${score/questions.length >= 0.66 ? 'correct':'wrong'}">${pct}%</span>
    `;
    summaryList.innerHTML = '';
    userAnswers.forEach((a, i) => {
      const div = document.createElement('div');
      div.className = 'summary-item';
      const pickedText = a.picked != null ? `${a.picked+1}. ${a.choices[a.picked]}` : '미응답';
      const correctText = `${a.correctIndex+1}. ${a.choices[a.correctIndex]}`;
      div.innerHTML = `
        <div><strong>${questions[i].no}번</strong>
          <span class="pill ${a.correct ? 'correct' : 'wrong'}">${a.correct ? '정답' : '오답'}</span>
        </div>
        <div class="muted" style="margin-top:4px;">${a.stem}</div>
        <div style="margin-top:8px;">
          <div><strong>선택:</strong> ${pickedText}</div>
          <div><strong>정답:</strong> ${correctText}</div>
          <div style="margin-top:6px;"><strong>해설:</strong> ${a.explain}</div>
        </div>
      `;
      summaryList.appendChild(div);
    });
  }

  function restart() {
    current = 0; score = 0; userAnswers.length = 0;
    resultCard.style.display = 'none';
    quizCard.style.display = 'block';
    renderQuestion();
  }

  nextBtn.addEventListener('click', onNext);
  restartBtn.addEventListener('click', restart);
  restartBtn2.addEventListener('click', restart);

  renderQuestion();
</script>
</body>
</html>
